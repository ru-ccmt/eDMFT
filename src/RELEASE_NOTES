New in this version

1) CTQMC was substantially reconfigured. The Green's function or self-energy 
  (or even the two particle vertex) can now be sampled both in the Matsubara frequency (old way)
   and in more efficient SVD basis ( These are SVD vectors of the analytic continuation kernel). 
   This last method removes all noise at intermediate frequency.

   We also made all arrays dynamic, so that Nmax variable (maximum perturbation order) is not needed anymore.

   Acceptance step was speed up substantially by taking into account proportionality of the state_evolutions.

   The self-energy sampling should now work in general, although it seems to have some issue in non-segment picture.

   The exchange move was implemented in general case. We added a set of new variables, in particular mode. 
   The new tutorial on ctqmc explains all details of the ctqmc:

   http://hauleweb.rutgers.edu/tutorials/Tutorial0.html

2) Spin-orbit coupling should be much faster now with MPI communication for both lapw1 and lapwso. 
   When we deal with large vector files, we can now use efficient mpi parallelization and 
   distribute vectors over many processors, or, merge into a single vector file through
   MPI calls. Both ways should work.

3) Resonant X-ray  scattering implemented, although not documented yet.

4) more user frienly scripts : findRot.py, local_axis.py and local2global.py

5) dmft1 now uses less memory, hence larger unit cell should now work.

6) Exact double couniting should work now. We have "exactd" (better for insulators), 
   "exact" and "exacty" (better for metals), which differ in real space screening.

7) Optimization of structures should work now.

8) Ferromagnetic metals now work even in the absence of SO. One needs to prepare
   case.indmfldn (for spin-down) as well as case.indmfl (for spin-up) file. 
   The impurity input file case.indmfi should ecompass both spin-up and spin-down
   components.
   In addition, params.dat should have a variable "Ferro=True" set, which will
   print eigenenergies for both up and down spins, and then compute chemical potential
   in the presence of both spins. The dmft2 calculation will then skip recomputing 
   the chemical potentail.

9) Forces are implemented and work.

10)ctqmc is much better now for 'Ising' interaction, i.e., much more
   trial steps are accepted. It seems slower for the same M, but it
   has roughly 5-times better statistics, or, it is 3-times more
   efficient. New Monte-Carlo step is implemented, which considerably
   reduces auto-correlation time.

11)total energies are working. They are printed in info.iterate. In
   addition, free energy can be calculated. We print F+T*S_imp. One
   can also calculate S_imp (by raising the temperature in impurity
   calculation) and get DMFT free energy.

12)Double countings have changed. In addition to the old "nominal"
   double counting, we support now "exact" double counting, and 
   "exactd" double counting, as well as well as
   other standard forms such as fully localized ("FLL") and around
   mean field ("AMF").
  "exactd" uses dielectric screening model, while "exacty" uses Yukawa model
  for real space Coulomb interaction. "exact" is a mixture of the two, which 
  should be more universal.


13)Much more flexible projectors are now implemented. For example,
   projector4 is similar to projector2, however, it projects to the
   same set of bands throughout the Brillouin zone. Projector5 also
   projects to the fixed set of bands, but it can take an arbitrary
   radial wave function as the projector "projectorw.dat". This wave
   function can be generated by "wave.py". The cut-off in real space
   does not need to be at the muffin-thin radius, but the projector
   wave function can extend arbitrary far into interstitial. To use
   that, an extra radius should be set in case.indmfl file.

14) several bug fixes....


----------------------------------------------
Previous versions
1) Bug correction: If you have two orbitals correlated on the same atom, previous version would not properly work. You are forced to use this version.

2) In this version we use projector which is localy *exactly* orhonormal. In the past code, U*U^+ was set to unity on diagonal, while in the off-diagonal, this projector could have some small
   non-zero components (due to non-completeness of Kohn-Sham basis). The rational was not to mix (l,m) states during orthonormalization. We decided to change that, so that U*U^+=1 exactly. 
   This is convenient when crystal-fields are being diagonalized, and impurity levels from case.outdmft1.0 are being used. In the previous versions, the diagonalization of impurity levels would
   not lead to exactly diagonal matrix of hybridization. In this version, it should.

3) NCA code is now faster : it supports open_mp in many more places.

In addition to other minor bug corrections, this version has the following features

1) The code supports parallel execution of wien2k. You should just set up a machine-file 
  for  wien2k, and dmft will use the same machines and parallelization as wien2k.

 You might add the following to your submittion script, to create the machine file for wien2k:

$WIEN_DMFT_ROOT/createW2kmachinef.py $JOBNAME.klist $TMPDIR/machines

  you have to specify $JOBNAME == case

2) In this version, open_mp is supported for dmft1 and dmft2 steps. This can substantially 
  speedup calculation with many atoms per unit cell. We use MPI for k-point parallelization, 
  and open_mp parallelization (possible only on multicore processors) for frequency, atoms, radial mesh, etc. 
  This parallelization is not 100% efficient, as k-point parallelization, however, it becomes very 
  efficient for large unit cell calculations.
  
  To use open_mp parallelization, you must switch on -openmp flag during compilation of dmft1 and dmft2.
  You also need to modify submition script, and switch on environment variable OMP_NUM_THREADS. If you have 
  roughly twice as many cores as is the number of k-points, you should use OMP_NUM_THREADS=2 and run MPI
  on every second core from machine file. If more cores are available, one can use all cores within one CPU
  for open_mp, and use only one MPI call per processor (not core). 
  The submittion script should look like:

  a) Define mpi_prefix.dat as before for ctqmc:

>mpi_prefix="/opt/mpich2/intel/13.0/bin/mpiexec -port $port -np $NSLOTS -machinefile $TMPDIR/machines -env OMP_NUM_THREADS 1 -envlist LD_LIBRARY_PATH,SCRATCH,WIEN_DMFT_ROOT,PYTHONPATH,WIENROOT " 
>echo $mpi_prefix > mpi_prefix.dat

  b) Create Wien2k machine file .machines by executing:

>$WIEN_DMFT_ROOT/createW2kmachinef.py $JOBNAME.klist $TMPDIR/machines

  c) Create the second mpi_prefix.dat2, which is used now by dmft2 and dmft (mpi_prefix used only by ctqmc) by

$WIEN_DMFT_ROOT/createDMFprefix.py $JOBNAME.klist mpi_prefix.dat > mpi_prefix.dat2

  This will set OMP_NUM_THREADS to value > 1, and will set up "wmachines" file with only a fraction of the original
  cores in the list.


3) Spin rotations are properly implemented. When spin-orbit coupling is present and the 
  local coordinate system is different from the global cooredinate system, the earlier 
  versions of the code did not work properly. This version should work.
  This also eliminates the need to put idenity as first transformation, because this 
  problem was due to inproper rotation of spin. In previous version there was a small error
  in spin-rotations when only z-rotation was present. Fixed.

4) This version allows many more correlated atoms as the old version. The code should 
  support up to 100 correlated atoms in the unit cell.

5) The ctqmc code should be substantially faster when the rotationally invariant Coulomb 
  interaction is considered. We implemented the "FastTrace" and "LazyTrace" evaluation, 
  which can give up to 6-times faster execution of ctqmc.

6) There should be no need to install "Python CXX" package in this version of the code.

7) The code suports non-colinear magnetism. This is still in development status.

8) It contains a script which can add exact crystal fields on full-slater interaction. This can be done by the script:
  impurity/addCF/cixaddCF.py
